---
title: Python Crypto Operations
description: 
tags:
    - Cryptography
refs:
date: 2023-07-22
draft: false
---

## Conversion

### Binary

```python
# 4-bit -> 8-bit
'1101'.zfill(8) # 00001101

# 4-bit -> 16-bit
'1101'.zfill(16) # 0000000000001101
```

### Binary/Number

```python
# N-bit -> int
int("1101", 2) # 13
int("1101", 4) # 81
int("1101", 8) # 577

# int -> N-bit
format(123, 'b') # 1111011

# int -> 8-bit
'{0:08b}'.format(123, 'b') # 01111011
format(123, 'b').zfill(8)
```

### Binary/Character

```python
# character -> N-bit
char = 'a'
format(ord(char), 'b') # 1100001

# chracter -> 16-bit
char = 'a'
'{0:016b}'.format(ord(char), 'b') # 1100001
'{0:016b}'.format(ord(char), 'b') # 0000000001100001
```

### Binary/String

```python
# string -> binary
bin_str = ""
for c in "Hello":
    c_bin = bin(ord(c))[2:] # remove "0b" prefix
    bin_str += c_bin.zfill(8) # padding to 8-bit
print(bin_str)
```

### Bytes/Int

```python
# bytes -> int
int.from_bytes(b'\x00\x01', "big") # 1
int.from_bytes(b'\x00\x01', "little") # 256

# int -> bytes
num = 1234
num.to_bytes(2, 'big') # b'\x04\xd2'
num.to_bytes(2, 'little') # b'\xd2\x04
```

### Bytes/Hex

```python
# bytes -> hex
b'Hello World'.hex() # 48656c6c6f20576f726c64

# hex -> bytes
bytes.fromhex('48656c6c6f20576f726c64') # b'Hello World'
```

### Bytes/String

```python
# bytes -> string
b'Hello'.decode('utf-8') # Hello
bytes.decode(b'Hello', 'utf-8')
codecs.decode(b'Hello', 'utf-8')

# string -> bytes
"Hello".encode('utf-8') # b'Hello'
bytes("Hello", 'utf-8')
```

### Character/Unicode

```python
# chracter -> unicode
ord('a') # 97

# unicode -> chracter
chr(97) # a
```

### Int/Hex

```python
# int -> hex
hex(448378203247) # 0x68656c6c6f

# hex -> int
int("68656c6c6f", 16) # 448378203247
```

### Int/String

```python
# int -> string
str(123) # "123"

# string (number) -> int
int("123") # 123

# string (text) -> int
decimal_str = ""
for c in "Hello":
	decimal_str += str(ord(c))
print(int(decimal_str)) # 72101108108111
```

<br />

## Bitwise Operations

### AND (&)

```python
24 & 72 # 8
0x18 & 0x48
bin(24 & 72) # '0b1000'
```

### OR (|)

```python
24 | 72 # 88
0x18 | 0x48
bin(24 | 72) # '0b1011000'
```

### XOR (^)

```python
24 ^ 72 # 80
0x18 ^ 0x48
bin(24 ^ 72) # 0b1010000
```

- **Brute Force XOR Key with 0/Null**

    If we specify a value to 0 or `\x00`, the result is the key as it is. By using it, we may be able to get the XOR key.

    ```python
    0 ^ 1 # 1
    0 ^ 2 # 2
    0 ^ 999 # 999

    # get the XOR key by brute force
    arr = zip(b'\x00', b'secret')
    bytes([a ^ b for a, b in arr]) # 's'

    arr = zip(b'\x00\x00', b'secret')
    bytes([a ^ b for a, b in arr]) # 'se'
    ...
    arr = zip(b'\x00\x00\x00\x00\x00\x00', b'secret')
    bytes([a ^ b for a, b in arr]) # 'secret'
    ```

### Shift (<<, >>)

```python
# Left bit shift (0100 -> 1000)
8 << 1 # 4
0b1000 << 1
bin(8 << 1) # 0b1000

# Right bit shift (1000 -> 0100)
8 >> 1 # 8
0b1000 >> 1
bin(8 >> 1) # 0b100
```

<br />

## Pow (Exponential)

```python
pow(2, 4) # 2 ** 4 = 16
pow(2, 4, 6) # 2 ** 4 % 6 = 4

# Inverse
from Crypto.Util.number import inverse
inverse(3, 10) # 7
pow(3, -1, 10) # 7
```

<br />

## GCD (Greatest Common Divisor)

```python
from math import gcd

gcd(2, 4) # 2
gcd(6, 18) # 6
```

### Co-prime Numbers

```python
# if these values are all prime numbers...
a = 2
b = 3
c = 5

gcd(a*b, a*c) # 2 (a)
gcd(b*a, b*c) # 3 (b)
gcd(c*a, c*b) # 5 (c)
```
